
# Documentation 1



### Midterm Project Description and Plan:

For my midterm project, I decided to create a maze game with a time limit. I will have a main character in my game which will be the object. This object should solve the maze and get to the finish line as fast as possible while being careful of the time. If the player gets to the finish line on time they win and if they fail to they lose.  While planning my game I split the creation of it into parts: maze creation, object creation, timer, win/lost signs, and play again sign to restart the game. I began to plan what I want the layout of my maze to look like. Therefore, I drew a sketch of my idea to have it handy when I get to the programming of the maze. 

#### Digital Maze Sketch:
![Sketch](https://github.com/FatemaAlhameli/Intro-to-IM-/blob/main/Maze%20Sketch.jpg)

#### Maze Creation Research Phase:

Before starting the maze creation I researched a couple of ways how mazes are constructed in p5.js. By following a maze algorithm from a [youtube video](https://youtu.be/HyK_Q5rrcr4) as a reference to prepare for the maze creation. The algorithm starts with creating a cell object which is part of a grid. Ultimately, this grid is the layout or template that will be manipulated to create the maze. The grid is generated by using an array that contains columns and rows of cells with i and j variables. Each cell is drawn with four lines top, right, bottom, left. I created another array with a boolean to know whether the sidelines of the cells are true or false. After this, I proceeded to see how I could start from one of these cells on the grid and decide what walls to remove in order to start having the grid look like a maze. Proceeding, the program should indicate which cells on the grid have been visited; this includes its neighboring cells. So, in order to know if the current(starting) cell has been visited I used this.visited and an if statement that indicates if a cell has been visited, it should be colored in green. In the next steps of the algorithm, we need to know if the neighbors of the current cell have been visited. 

Each cell has four neighbors top, right, bottom, and left. The current cell coordinates are (i, j), so the coordinates of the top cell are (i, j-1), right cell (i+1, j), bottom cell (i, j+1), and left cell (i-1, j). What I need to do is check if these neighbors are visited or not. As initialized by the algorithm, I needed to create a function called index, and the index is able to have (i, j) coordinates. This will allow me to identify all the neighbors and indicate if they have been visited or not. Although this is a great way to proceed, you face the obstacle of when a cell is on the sides of the grid; it does not have all four neighbors; it only has three. The algorithm suggests that I use an if statement that says if i is less than zero or j is less than 0, or i is greater than the number of columns -1, or j is greater than the number of rows -1, then the visited cell should return to -1.  In addition, to let the neighbor cells be picked randomly, I need an if statement that specifies if neighbors.length is greater than 0, let the program pick a random neighbor. Then to show if the neighboring cells are visited, I need to create a variable that specifies if the next cell is visited to make it true. This will allow the random cell that is picked to be colored and shown when the program runs. Now when the program runs,  specific cells are colored until it gets to a place on the grid where there are no more neighboring cells that have not been visited. 


[Current Code Progress](https://editor.p5js.org/FatemaAlhameli/sketches/mRNiGuhJ0)
```
let cols;
let rows;
let current;
let size = 40;
let cells = [];
function setup() {
  createCanvas(400, 400);

  cols = floor(width / size);
  rows = floor(height / size);
  frameRate(5);

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let cell = new Cell(j, i);
      cells.push(cell);
    }
  }
  current = cells[0];
}

function draw() {
  background(220);
  for (let i = 0; i < cells.length; i++) {
    cells[i].show();
  }
  current.visited = true;
  let next = current.checkNeighbors();
  if (next) {
    next.visited = true;
    current = next;
  }
}
function index(i, j) {
  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
    return -1;
  }
  return i + j * cols;
}

function Cell(i, j) {
  this.i = i;
  this.j = j;
  this.walls = [true, true, true, true];
  this.visited = false;
  this.checkNeighbors = function () {
    let neighbors = [];

    let top = cells[index(i, j - 1)];
    let right = cells[index(i + 1, j)];
    let bottom = cells[index(i, j + 1)];
    let left = cells[index(i - 1, j)];

    if (top && !top.visited) {
      neighbors.push(top);
    }
    if (right && !right.visited) {
      neighbors.push(right);
    }
    if (bottom && !bottom.visited) {
      neighbors.push(bottom);
    }
    if (left && !left.visited) {
      neighbors.push(left);
    }
    if (neighbors.length > 0) {
      let r = floor(random(0, neighbors.length));
      return neighbors[r];
    } else {
      return undefined;
    }
  };

  this.show = function () {
    let x = this.j * size;
    let y = this.i * size;
    stroke(255);
    if (this.walls[0]) {
      line(x, y, x + size, y);
    }

    if (this.walls[1]) {
      line(x + size, y, x + size, y + size);
    }

    if (this.walls[2]) {
      line(x + size, y + size, x, y + size);
    }

    if (this.walls[3]) {
      line(x, y + size, x, y);
    }
    if (this.visited) {
      fill(52, 235, 58, 100);
      rect(x, y, size, size);
    }
  };
}
```
