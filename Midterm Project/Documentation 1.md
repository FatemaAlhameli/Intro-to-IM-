
# Documentation 1



### Midterm Project Description and Plan:

For my midterm project, I decided to create a maze game with a time limit. I will have a main character in my game which will be the object. This object should solve the maze and get to the finish line as fast as possible while being careful of the time. If the player gets to the finish line on time they win and if they fail to they lose.  While planning my game I split the creation of it into parts: maze creation, object creation, timer, win/lost signs, and play again sign to restart the game. I began to plan what I want the layout of my maze to look like. Therefore, I drew a sketch of my idea to have it handy when I get to the programming of the maze. 

#### Digital Maze Sketch:
![Sketch](https://github.com/FatemaAlhameli/Intro-to-IM-/blob/main/Maze%20Sketch.jpg)

#### Maze Creation Research Phase:

Before starting the maze creation I researched a couple of ways how mazes are constructed in p5.js. By following a maze algorithm from a [youtube video](https://youtu.be/HyK_Q5rrcr4) as a reference to prepare for the maze creation. The algorithm starts with creating a cell object which is part of a grid. Ultimately, this grid is the layout or template that will be manipulated to create the maze. The grid is generated by using an array that contains columns and rows of cells with ```i``` and ```j``` variables. Each cell is drawn with four lines top, right, bottom, left. I created another array with a boolean to know whether the sidelines of the cells are true or false. After this, I proceeded to see how I could start from one of these cells on the grid and decide what walls to remove in order to start having the grid look like a maze. Proceeding, the program should indicate which cells on the grid have been visited; this includes its neighboring cells. So, in order to know if the current(starting) cell has been visited I used ```this.visited``` and an if statement that indicates if a cell has been visited, it should be colored in green. In the next steps of the algorithm, we need to know if the neighbors of the current cell have been visited. 

Each cell has four neighbors top, right, bottom, and left. The current cell coordinates are ```(i, j)```, so the coordinates of the top cell are ```(i, j-1)```, right cell ```(i+1, j)```, bottom cell ```(i, j+1)```, and left cell ```(i-1, j)```. What I need to do is check if these neighbors are visited or not. As initialized by the algorithm, I needed to create a function called index, and the index is able to have ```(i, j)``` coordinates. This will allow me to identify all the neighbors and indicate if they have been visited or not. Although this is a great way to proceed, you face the obstacle of when a cell is on the sides of the grid; it does not have all four neighbors; it only has three. The algorithm suggests that I use an if statement that says if i is less than zero or j is less than 0, or i is greater than the number of columns -1, or j is greater than the number of rows -1, then the visited cell should return to -1.  In addition, to let the neighbor cells be picked randomly, I need an if statement that specifies if ```neighbors.length``` is greater than 0, let the program pick a random neighbor. Then to show if the neighboring cells are visited, I need to create a variable that specifies if the next cell is visited to make it true. This will allow the random cell that is picked to be colored and shown when the program runs. Now when the program runs, if a current cell has neighbors which have not been visited then the program will randomly choose an unvisited cell and will be noticeable by being colored. 

![Maze Progress](https://github.com/FatemaAlhameli/Intro-to-IM-/blob/main/Maze%20progress%201.png)

In my next steps of creating a maze, I need to remove the walls between the current cell and the neighboring cell on the grid. By creating a function called ```removeWalls```, it will the program to take two cells and remove the wall that is in between them. These cells will be referred to as ```(a,b)``` in the code. Now, if the code runs the walls of the cells(square) are removed. Hence, the canvas is beginning to look like a maze. However, when the current cell gets to a certain point where there are no more unvisited cells it gets stuck and stops trying to figure out the maze. Therefore, the current cell needs to be able to backtrack. 

Similar to an array, a stack is another form of a data structure that literally functions like a stack of things. In the algorithm, an array is used to program a stack by because ```push();``` and a ```pop();``` function. By adding a stack to the program, it will allow the current cell if it is stuck to go to the stack/array to find a new spot, thus it backtracks to complete the maze. 

![Maze Progress2](https://github.com/FatemaAlhameli/Intro-to-IM-/blob/main/Maze%20progress%202.png)

#### Next Steps in Maze Creation:

- Clean up code: I will need to move my class function into a separate file to have a cleaner code.
- Try and figure out how to have my program begin with a maze rather than wait for it to be generated.
- Add an endpoint, to show the player where they should strive to reach.

[Current Code Progress](https://editor.p5js.org/FatemaAlhameli/sketches/mRNiGuhJ0)
```
let cols;
let rows;
let current;
let size = 40;
let cells = [];

let stack = [];

function setup() {
  createCanvas(400, 400);

  // Size of cells
  cols = floor(width / size);
  rows = floor(height / size);
  frameRate(100);

  //Loops to create all the cells in the rows and columns and store in an array
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let cell = new Cell(j, i);
      cells.push(cell);
    }
  }
  current = cells[0];
}

function draw() {
  background(220);
  // Loop through all cells to display on canvas
  for (let i = 0; i < cells.length; i++) {
    cells[i].show();
  }
  current.visited = true;
  current.highlight();

  let next = current.checkNeighbors();
  if (next) {
    next.visited = true;
    stack.push(current);
    removeWalls(current, next);
    current = next;
  } else if (stack.length > 0) {
    current = stack.pop();
  }
}

function index(i, j) {
  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
    return -1;
  }
  return i + j * cols;
}

//Cell objects with i = columns and j = rows
function Cell(i, j) {
  this.i = i;
  this.j = j;
  this.walls = [true, true, true, true];
  this.visited = false;
  this.checkNeighbors = function () {
    let neighbors = [];

    // For Neighboring Cells
    let top = cells[index(i, j - 1)];
    let right = cells[index(i + 1, j)];
    let bottom = cells[index(i, j + 1)];
    let left = cells[index(i - 1, j)];

    if (top && !top.visited) {
      neighbors.push(top);
    }
    if (right && !right.visited) {
      neighbors.push(right);
    }
    if (bottom && !bottom.visited) {
      neighbors.push(bottom);
    }
    if (left && !left.visited) {
      neighbors.push(left);
    }

    // Random cells selected
    if (neighbors.length > 0) {
      let r = floor(random(0, neighbors.length));
      return neighbors[r];
    } else {
      return undefined;
    }
  };
  this.highlight = function () {
    let x = this.i * size;
    let y = this.j * size;
    noStroke();
    fill(40, 89, 235);
    rect(x, y, size, size);
  };

  this.show = function () {
    let x = this.i * size;
    let y = this.j * size;
    stroke(255);

    // Walls of a single cell
    if (this.walls[0]) {
      line(x, y, x + size, y);
    }

    if (this.walls[1]) {
      line(x + size, y, x + size, y + size);
    }

    if (this.walls[2]) {
      line(x + size, y + size, x, y + size);
    }

    if (this.walls[3]) {
      line(x, y + size, x, y);
    }
    // If a cell(square) is visted it will be colored green
    if (this.visited) {
      noStroke();
      fill(15, 212, 67);
      rect(x, y, size, size);
    }
  };
}

function removeWalls(a, b) {
  let x = a.i - b.i;
  if (x === 1) {
    a.walls[3] = false;
    b.walls[1] = false;
  } else if (x === -1) {
    a.walls[1] = false;
    b.walls[3] = false;
  }
  let y = a.j - b.j;
  if (y === 1) {
    a.walls[0] = false;
    b.walls[2] = false;
  } else if (y === -1) {
    a.walls[2] = false;
    b.walls[0] = false;
  }
}


```
